# Microcorruption CTF - Hollywood (300 points)

## Problem

One last time -- find an input that opens the door. This level is radically different to the last, and will require dynamic analysis as well as programming skills.
Are you ready?

![manual](https://user-images.githubusercontent.com/86139991/128721996-7ee35f87-f4de-4927-a02d-f77018c91182.PNG)

## Reasoning

## The black box

This time, we barely have any code to analyze. All we're given is one obfuscated block:

![main_obfuscated](https://user-images.githubusercontent.com/86139991/128722325-6aebb6a7-17ed-4475-938a-fb44e86e0d89.PNG)

Running it reveals that we are prompted to enter a password. Entering random gibberish causes the program to exit immediately without printing any status messages.

A quick scan of memory reveals no legible strings, indicating that the majority of the code is almost certainly obfuscated. Time to roll up our sleeves and step through
the code manually.

## Discovering the main loop

The code starts off by copying a large chunk of memory from bytes `0x4634-0x5734` to a chunk starting at address `0x2400`, then copies again from `0x2400` to `0x1400`.
It then branches to the code at `0x44be` -- an address outside of the decompiled range.

At this point, the code enters its main loop: a series of operations that is called over and over to execute the actual program. It goes like this:

1. A random number is generated by placing `0xa000` in the status register (recall from [Level 15](https://github.com/cd80-ctf/microcorruption/tree/main/Level%2015%20%7C%20Bangalore)
that this is `0x(80 + number of interrupt)00`). The random number is then moved into r12, and stripped of its highest digit and lowest bit using `and 0xffe, r12`.
Finally, the first digit of `r12` is set to `e`. The fact that the lowest bit is set to 0 implies that this value needs to be aligned.
This suggests that it'll be used as an address for something, be it instructions or data, and that this object will always be stored at a random location in the the
`0xe000` block.
2. Several values are run through a complex algorithm with lots of `rra`'s and `xor`'s and then copied to memory starting at `r12`. We can safely assume that this
is a de-obfuscation function, and the data copied to `r12` is now in plaintext.
3. Three things happen in succession: the status register (`sr`) is popped, **the address in `r12` is called**, a new address in the `0x4000` range is stored in `r12`,
and the status register is pushed. The popping and pushing of `sr` indicates that the program wants to save the status of whatever's happening during these calls to `r12`. This, combined with the fact that the
first call to `r12` allocates space on the stack, leads us to conclude that **the values copied to r12 are the de-obfuscated instructions of the real program**.
4. Having run all the code at `r12`, we jump back to the main loop. All the values copied to `r12` are cleared (thwarting any post facto analysis).
5. Another random number is generated. This time it is masked with `and 0x1ff0` and shifted to be in the `0x8000-0xf000` range. Again, note the aligning of the address.
6. The current instruction pointer is moved into `r14`, and **the code copies itself to the random address in `r13`.** Once this is done, the old code (up to the
current instruction) is zeroed out, and we jump to the new code, thus starting the loop again.

In short, the program de-obfuscates one instruction at a time, runs it at a random location in the `0xe000` range, copies the de-obfuscation code to a random address
in the `0x8000-0xf000` range, zeroes out all previous code, and repeats.

This looks like a pain to analyze. Thankfully, we can skip past all the boilerplate and only see the "real" program instructions by the following method:

1. Stepping through the program manually until the first "real" instruction,
2. Noting the "real" instruction,
3. Skipping 30 instructions with `s 30` to skip the generation of the random number in `r15`,
4. Replacing the first digit of `r15` with `e` to get the address of the next "real" instruction,
5. Setting a breakpoint at this address and continuing execution with `c` until we reach it.

## The true code

In this way, we can extract the "true" code of the program. In pseudocode, this looks like:

```
print "What's the password?" one character at a time
get the response and store it at 0x2600
for every two bytes in the password, run a hash algorithm that updates r4 and r6
when the last byte of the password is processed:
  check if r4 = 0xfeb1
  check if r6 = 0x9298
  
  if both registers match, open the door
  otherwise, set the CPUOFF bit of the status register, ending the program
```

The exact hash algorithm is fairly simple, and can be understood as the following Python script:

```py
def password_hash(word, r4, r6):
  r4 += word
  swap_bytes(r4)
  
  r6 ^= word
  
  r6 ^= r4 // swap the values in r4 and r6
  r4 ^= r6
  r6 ^= r4
```

The program also does some nonsense with `r7` and `r8` in the hash. This is a red herring, and irrelevant to whether or not we get paid.

This code was pieced together with heavy reference to the [MSP430 manual](https://www.ti.com/lit/ug/slau144j/slau144j.pdf?ts=1628447142245), specifically the page
regarding the status register. It is vital to understand what each bit of this register represents to see exactly what the program is doing. For example, when comparing
`r4` and `r6` to their correct values at the end, the program uses the following trick to place 1 in `sr`'s CPUOFF bit (at offset 4) if and only if one of the
comparisons didn't match (that is, if at least one of the comparisons didn't leave a `1` in `sr`'s zero bit):

```
cmp(0xfeb1, r4)
r7 = sr
r4 = 0 // frustrate dynamic analysis
cmp(0x9298, r6)
r7 = sr & r7 // ensures the 'zero bit' (offset 1) in r7 is 1 if and only if the zero bit was 1 in both comparisons (i.e. if both comparisons matched)
r6 = 0 // frustrate etc.

rra(r7) // swap the zero bit to the first digit
r7 = xor(1, r7) // sets r7 to (0x1 xor 0x1 = 0x0) if the zero bit was set, or (0x1 xor 0x0 = 0x1) if the zero bit wasn't set
swap_bytes(r7) // sets r7 to 0x0100 if it was 0, or to 0 if it had the 1 bit set
rra(r7) // sets r7 to 0x0080 if it was 0, or to 0 if it had the 1 bit set
rra(r7) // sets r7 to 0x0040 if it was 0, or to 0 if it had the 1 bit set
rra(r7) // sets r7 to 0x0020 if it was 0, or to 0 if it had the 1 bit set
rra(r7) // sets r7 to 0x0010 if it was 0, or to 0 if it had the 1 bit set
bis(r7, sr) // SETS THE FOURTH BIT OF THE STATUS REGISTER (CPUOFF) TO 1 IFF BOTH ZERO BITS WEREN'T 1
// if we've gotten here, unlock the door
```

## Brute forcing the correct hash

Since we're given no further info, we must assume that we're meant to brute-force an input that sets the `r4` and `r6` to their correct values.

This was done using the [brute_force.c](https://github.com/cd80-ctf/microcorruption/blob/main/Level%2018%20%7C%20Hollywood/brute_force.c) script in this directory.
The shortest password we found that opens the lock was six characters, found after about an hour of searching.

The leaderboard indicates that 5 characters is possible. This solution could be found by replacing the restriction on the range of `second_char` with a restriction on 
the range of `first_char`.

As always, remember to input these values in reverse-endian order!

## Solution

`a131a37f00ba` in hex.

Congratulations! If you've made it this far, you've proven you're quite the capable hacker.
